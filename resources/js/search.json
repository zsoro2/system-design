[[{"l":"Welcome"},{"l":"Introduction","p":["Welcome to my System Design Notes! This repository is a comprehensive summary of what I have learned about System Design. These are notes for my future self. Whether you're preparing for technical interviews, looking to improve your skills, or simply interested in system architecture, this resource aims to provide valuable insights and practical knowledge in a nutshell."]}],[{"l":"Social sites"},{"l":"Calculations","p":["100 charaters / post = 100 bytes","100 charaters / metadata = 100 bytes","1.000.000.000 (1Billion) post data / day","Total: 1B * 200 * 365days/year = 73000 TB = 73PB"]},{"l":"Timeline read"},{"l":"Fanout on Write","p":["Description: Pre-compute the news feed during write time.","Pros:","Real-time feed generation, instantly pushing new posts to friends' caches.","Fast feed fetching due to pre-computation.","Cons:","Slow and resource-intensive for users with many friends.","Wastes resources on inactive users."]},{"l":"Fanout on Read","p":["Description: Generate the news feed during read time.","Pros:","Efficient for inactive users, saving computing resources.","Avoids the hotkey problem.","Cons:","Slower feed fetching since it's computed on-demand."]},{"l":"Hybrid Approach","p":["Push Model:","Used for most users.","Pre-compute and cache the news feed during write time.","Pull Model:","Used for users with many followers (e.g., celebrities).","Fetch and merge recent posts on-demand during read time.","Consistent Hashing:","Distributes requests and data evenly to mitigate the hotkey problem."]},{"l":"Services","p":["User Service API","Feed Service API","Notification Service API","Search Service API","Messaging Service API"]},{"l":"Resources","p":["Facebook system design Youtube - Instagram + Twitter + Facebook + Reddit"]}],[{"l":"Data structures","p":["Data Structure","Best for","Key Points","Hashmaps","Fast lookups","In memory, loses data if off, no range queries","B-Trees","Database searches","On disk, supports range queries","LSM Trees","Heavy writing","Writes to memory first, then sorted to disk"]},{"l":"Hasmaps","p":["Best for: Fast lookups in memory.","Key Points:","Data is kept in memory.","Loses data if the computer shuts down.","Slow on disk.","No range queries."]},{"l":"B-Trees","p":["Best for: Databases with lots of searches.","Key Points:","Data is always on disk.","Good for range queries.","Efficient for frequent searches, inserts, and deletes.","Used in file systems and database indexes (e.g., MySQL, PostgreSQL)"]},{"i":"lsm-tree-mostly-nosql-like-cassandra","l":"LSM Tree (mostly nosql like Cassandra)","p":["Best for: Heavy writing.","Key Points:","Writes data to memory first.","Moves data to disk in sorted order when memory is full, called SSTable.","Reading can get slower with more and more SSTable created on disk.","Widely used in NoSQL databases like Cassandra, HBase, and LevelDB.","Supports high scalability and can handle large datasets efficiently."]},{"l":"In Summary","p":["Hashmaps: Fast lookups in memory, used for caching or in-memory databases.","B-Trees: Efficient on-disk storage, used in relational databases for indexing.","LSM Trees: High write throughput, used in NoSQL databases for handling heavy writes."]}],[{"l":"Data warehouse"},{"i":"what-are-data-warehouses","l":"What are Data Warehouses?","p":["A data warehouse is a centralized repository that stores large amounts of structured data from multiple sources. It is designed for query and analysis rather than transaction processing. Data warehouses support business intelligence activities, such as reporting, data analysis, and data mining, providing valuable insights for decision-making."]},{"i":"data-extraction-transformation-and-loading-etl","l":"Data Extraction, Transformation, and Loading (ETL):","p":["Extraction: Data is collected from various source systems like transactional databases, CRM systems, and flat files.","Transformation: The extracted data is cleansed, formatted, and transformed into a consistent structure.","Loading: The transformed data is loaded into the data warehouse."]},{"l":"Fact and Dimension Tables","p":["1","1001","101","150.00","2","201","2020","2020-01-01","20200101","35","75.00","age","category","Content: Contains foreign keys to dimension tables and metrics like sales amount and quantity sold.","Content: Contains primary keys and attributes like product name, customer location, and store region.","customer_dimension_table","customer_id","customer_name","date","date_dimension_table","date_id","Dimension Tables:","Example:","Examples:","Fact Tables:","Gadgets","Jan","John Doe","location","month","New York","price","product_dimension_table","product_id","product_name","Purpose: Provide context and descriptive information related to facts.","Purpose: Store measurable, quantitative data for analysis.","Q1","quantity_sold","quarter","sale_id","sales_amount","sales_fact_table","store_id","Widget A","year"]},{"i":"star-snowflake-olap","l":"Star, Snowflake, OLAP","p":["Star Schema: Simplifies queries by having a central fact table surrounded by dimension tables.","Snowflake Schema: Normalizes dimension tables to reduce redundancy but can complicate queries.","OLAP (Online Analytical Processing): Tools and techniques used to analyze data in the warehouse, often supporting complex queries and data aggregation."]}],[{"l":"Indexes","p":["B-Tree","Balanced tree, keeps data sorted","Best For","Can be slower for large datasets compared to clustered","Clustered","Complex to implement, can degrade with irregular data","Efficient for location-based queries","Efficient for quick lookups","Efficient searches, range queries","Exact match lookups","Extremely fast exact match lookups","Fast for retrieving ordered rows","Full-Text","General-purpose indexing","Geospatial queries","Handles complex text searches","Hash","Hash table, maps keys to values","Index Type","Inverted index, tracks word occurrences","Key Points","Limitations","Needs space and maintenance as it grows","No range queries, needs collision handling","Non-Clustered","Organizing rows by index key","Quick access to data","R-Trees, Quadtrees for spatial data","Resource-intensive, needs extra storage","Separate from table, contains pointers to data","Slower for inserts/updates due to reordering","Spatial","Stores actual table data at index leaf level","Strengths","Text search"]},{"l":"B-Tree Indexes","p":["General-purpose indexing in databases.","Key Points:","Structure: Balanced tree; keeps data sorted.","Performance: Good for finding specific values and range queries.","Uses: Common in MySQL, PostgreSQL, Oracle.","Strengths:","Efficient searches, inserts, and deletes.","Supports range queries.","Limitations: Requires more space and maintenance as it grows."]},{"l":"Hash Indexes","p":["Fast lookups for exact matches.","Key Points:","Structure: Hash table; maps keys to values.","Performance: Very fast for finding exact matches.","Uses: In-memory databases like Redis; some uses in MySQL.","Strengths:","Extremely fast exact match lookups.","Limitations:","No range queries.","Needs handling for hash collisions."]},{"l":"Full-Text Indexes","p":["Searching large text fields.","Key Points:","Structure: Inverted index; tracks occurrences of each word.","Performance: Optimized for text search.","Uses: Elasticsearch, MySQL, PostgreSQL for full-text search.","Strengths:","Handles complex searches (e.g., relevance, ranking).","Limitations:","Can be resource-intensive.","Requires additional storage space."]},{"l":"Clustered Indexes","p":["With a clustered index the rows are stored physically on the disk in the same order as the index. Therefore, there can be only one clustered index.","Key Points:","Structure: Stores actual table data at the leaf level of the index.","Performance: Fast for retrieving rows in sorted order.","Uses: Each table can have only one clustered index (e.g., primary key in SQL Server).","Strengths:","Fast data retrieval for ordered data.","Limitations:","Slower for insert and update operations due to reordering."]},{"l":"Non-Clustered Indexes","p":["With a non clustered index there is a second list that has pointers to the physical rows. You can have many non clustered indices, although each new index will increase the time it takes to write new records.","Key Points:","Structure: Separate from the table; contains pointers to the data.","Performance: Good for queries that don't require sorted data.","Uses: Multiple non-clustered indexes can exist per table.","Strengths:","Efficient for quick lookups.","Limitations:","Can be slower than clustered indexes for large datasets."]},{"l":"Spatial Indexes","p":["Geospatial queries and multi-dimensional data.","Key Points:","Structure: R-Trees, Quadtrees, etc.; organizes spatial data.","Performance: Efficient for spatial operations.","Uses: GIS, spatial databases like PostGIS, MySQL.","Strengths:","Efficient for location-based queries.","Limitations:","Complex to implement.","Performance can degrade with irregular data."]}],[{"l":"Replication"},{"l":"Overview","p":["Replication in databases is a technique used to ensure data redundancy and high availability by copying and maintaining database objects in multiple databases that make up a distributed database system. There are several types of replication strategies, each with its own use cases, advantages, and challenges."]},{"l":"Types of Replication"},{"l":"Single-Leader Replication"},{"l":"Leader","p":["Role: The primary node handling all write requests.","Responsibilities: Accepts write requests, updates local data, propagates changes to followers."]},{"l":"Follower","p":["Role: Secondary nodes that replicate the leader's data.","Responsibilities: Receive and apply data changes from the leader, serve read requests."]},{"l":"Read-Write Dynamics","p":["Writes: Only accepted by the leader.","Reads: Distributed across followers to balance load and improve read performance."]},{"l":"Advantages","p":["Simplifies conflict resolution since only one node handles writes.","Ensures data consistency at the leader."]},{"l":"Disadvantages","p":["Can be slow, if done synchronously.","Single point of failure unless proper failover mechanisms are in place."]},{"l":"Multi-Leader Replication"},{"l":"Use Cases","p":["Suitable for high availability and geographically distributed systems.","Allows multiple nodes to accept write requests."]},{"l":"Write Conflicts","p":["Conflict Detection: Conflicts are detected asynchronously.","Resolution Strategies: Application-specific logic, Last Write Wins (LWW), vector clocks, and CRDTs."]},{"i":"advantages-1","l":"Advantages","p":["Provides higher write availability and fault tolerance.","Reduces latency for geographically distributed nodes."]},{"i":"disadvantages-1","l":"Disadvantages","p":["Best Use Cases","Can be higher due to asynchronous conflict resolution","Common in databases like MySQL, PostgreSQL","Complex, involves resolving conflicts between leaders","Complexity","Conflict Resolution","Consistency","Easier, as only the leader handles writes","Eventual consistency, harder to guarantee immediate consistency","Examples","Failure Recovery","Fault Tolerance","Feature","Good for high availability and geographically distributed systems","Good for read-heavy workloads","High, as writes can go to multiple leaders","Higher for nodes far from the leader","Higher, due to managing multiple leaders and conflicts","Higher, with multiple leaders providing redundancy","Increased complexity in conflict detection and resolution.","Latency","Leader is a single point of failure","Limited to the leader's capacity","Lower for geographically distributed nodes","Lower, due to single-leader management","More complex due to conflict resolution needs","More complex, requires resolving conflicts between leaders","Multi-Leader Replication","Multiple leaders can handle write operations","Only one leader handles all write operations","Operational Overhead","Potential for data inconsistency if conflicts are not properly resolved. You can decide to implement some algorithm to automatically resolve conflicts in a consistent manner (e.g., using a unique ID composed of timestamp and randomly generated).","Promote a follower to be the new leader","Read Handling","Reads and writes can be handled by any leader","Reads are spread across followers","Replication Lag","Simpler to implement and manage","Single-Leader Replication","Stronger, easier to ensure immediate consistency","Typically lower due to single write path","Used in systems like Apache Cassandra, CouchDB","Write Availability","Write Handling"]},{"l":"Replication Techniques"},{"l":"Synchronous Replication","p":["Mechanism: Ensures data is written to the leader and at least one follower before acknowledging the write.","Pros: Reduces inconsistency.","Cons: Can impact performance and availability if synchronous followers experience downtime."]},{"l":"Asynchronous Replication","p":["Mechanism: Data is written to the leader first and then asynchronously propagated to followers.","Pros: Improves write performance.","Cons: Increases the window for potential inconsistency."]},{"l":"Setting Up New Followers"},{"l":"Process","p":["Snapshot: Take a consistent snapshot of the leader’s database.","Copy Snapshot: Transfer the snapshot to the new follower.","Catch-Up: The follower requests and applies changes from the leader that occurred since the snapshot.","Synchronization: Once caught up, the follower processes ongoing changes in real-time."]},{"l":"Replication Logs"},{"i":"write-ahead-log-wal-shipping","l":"Write-ahead Log (WAL) Shipping","p":["Description: Logs every modification and ships these logs to followers.","Pros: Simple, works at a low level.","Cons: Coupled to storage engine, may require downtime for upgrades."]},{"i":"logical-row-based-log-replication","l":"Logical (Row-based) Log Replication","p":["Description: Uses a log format decoupled from the storage engine, recording changes at the row level.","Pros: Easier upgrades and external parsing.","Cons: More complex to implement than WAL shipping."]}],[{"l":"Sharding and Partitioning"},{"l":"Introduction","p":["Sharding and partitioning are techniques used to distribute data across multiple machines to improve performance and scalability. The goal is to spread the data and query load evenly, avoiding hot spots and ensuring efficient data management."]},{"l":"Key Concepts"},{"l":"Skewed Partitioning","p":["Definition: When the partitioning is unfair, causing some partitions to have more data or queries than others. This imbalance can degrade performance and lead to hot spots."]},{"l":"Hot Spot","p":["Definition: A partition with a disproportionately high load. This can lead to performance bottlenecks and inefficient resource utilization."]},{"l":"Rebalancing","p":["Definition: The process of moving load from one node in the cluster to another to ensure even distribution of data and queries. This is crucial when nodes are added or removed from the cluster."]},{"l":"Hash Partitioning","p":["Definition: A method that uses a hash function to determine the partition for a given key. This helps in distributing the data evenly across partitions."]},{"l":"Consistent Hashing","p":["Definition: A specific type of hash partitioning that aims to minimize the amount of data that needs to be moved when nodes are added or removed. It helps in maintaining a balanced load.","Each object key will belong in the server whose key is closest, in a counterclockwise direction","Image from www.toptal.com"]}],[{"l":"Transactions","p":["A transaction groups several reads and writes into a single unit. It either completes successfully (commit) or fails (rollback)."]},{"l":"ACID Properties of a Transaction","p":["The safety guarantees provided by transactions are often described by the well-known acronym ACID.","Atomicity: Ensures that all operations within a transaction are completed; if not, the transaction is aborted and any changes are undone.","Consistency: Ensures that a transaction takes the database from one valid state to another, maintaining data integrity.","Isolation: Ensures that transactions do not interfere with each other, preventing concurrency issues.","Durability: Guarantees that once a transaction is committed, it remains so, even in case of a system failure, even if there is a hardware fault or the database crashes. Involves a write-ahead log."]},{"i":"transaction-isolation-levels-mysql--postgresql","l":"Transaction Isolation Levels (MySQL + PostgreSQL)","p":["READ UNCOMMITTED (weakest)","Explain: With this isolation level, transactions can read UNCOMMITTED data from other transactions, leading to dirty reads.","Example:","T1 and T2 start.","T1 updates a specific record with a new value.","T2 selects this record and gets the new value (this is a dirty read because T1 transaction is not committed yet, but T2 sees the new value).","READ COMMITTED","Explain: The transaction can only read the COMMITTED data, preventing dirty reads.","If T2 selects the same record, it will get the original data, not what T1 updated.","REPEATABLE READ (default level)","Explain: Transactions see consistent data during their execution, blocking non-repeatable reads but not phantom reads.","SERIALIZABLE (strongest)","Explain: This level locks the rows, preventing other transactions from modifying them until the transaction is committed.","Example: T1 will timeout or succeed as soon as T2 is committed."]},{"i":"concurrency-issues-race-conditions","l":"Concurrency Issues (Race Conditions)","p":["Come into play when one transaction reads data that is concurrently modified by another transaction, or when two transactions try to simultaneously modify the same data.","Dirty Reads: A transaction reads uncommitted data from another transaction.Imagine a transaction has written some data to the database, but the transaction has not yet committed or aborted. Can another transaction see that uncommitted data? If yes, that is called a dirty read. One client reads another client’s writes before they have been committed.","Dirty Writes: What happens if the earlier write is part of a transaction that has not yet committed, so the later write OVERWRITES an uncommitted value? This is called a dirty write.","Read Skew (Non-repeatable Reads): A transaction reads committed data multiple times but sees different values because another transaction has committed changes in between.","Lost Updates: Two clients concurrently perform a read-modify-write cycle. One overwrites the other’s write without incorporating its changes, so data is lost.","Write Skew: A transaction reads a value, makes a decision based on that value, but the premise of the decision is no longer true by the time the write is made.","Phantom Reads: A transaction reads a set of rows that satisfy a condition, and another transaction inserts, updates, or deletes rows that would affect the initial transaction’s result set if the same query were re-executed.","Two-phase locking: Writers don’t just block other writers; they also block readers and vice versa."]},{"l":"Solutions for Common Problems","p":["Avoid Read-Modify-Write Cycle","Focus on 'balance = balance - 100' section. Instead we select and then update, based on the selection value, we update with a variable.","Row Level Locking","Focus on 'for update' section.","Turn on SERIALIZABLE Isolation Level","Note: This can cause some performance issues.","Optimistic Locking","Allows multiple transactions to complete without locking the database.","Steps:","Add a version column:","Select based on the version column and other conditions:","Update the row based on the version:"]},{"i":"resources","l":"Resources:","p":["Production use Solutions"]}],[{"l":"Page title here","p":["This is a paragraph.","Both internal and external links work.","Your logo","Another paragraph with bold, italic, strikethrough, and code samples."]},{"l":"Lists","p":["First item","Second item","Third item","\"Cool! This is a quotation.\"","Need to draw attention to something? Use an alert."]}],[{"l":"Welcome"},{"l":"Introduction","p":["Welcome to my System Design Notes! This repository is a comprehensive summary of what I have learned about System Design. These are notes for my future self. Whether you're preparing for technical interviews, looking to improve your skills, or simply interested in system architecture, this resource aims to provide valuable insights and practical knowledge in a nutshell."]}]]