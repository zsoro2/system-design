[[{"l":"Welcome","p":["test"]}],[{"l":"Twitter posts publish","p":["asd"]}],[{"l":"Data structures","p":["Data Structure","Best for","Key Points","Hashmaps","Fast lookups","In memory, loses data if off, no range queries","B-Trees","Database searches","On disk, supports range queries","LSM Trees","Heavy writing","Writes to memory first, then sorted to disk"]},{"l":"Hasmaps","p":["Best for: Fast lookups in memory.","Key Points:","Data is kept in memory.","Loses data if the computer shuts down.","Slow on disk.","No range queries."]},{"l":"B-Trees","p":["Best for: Databases with lots of searches.","Key Points:","Data is always on disk.","Good for range queries.","Efficient for frequent searches, inserts, and deletes.","Used in file systems and database indexes (e.g., MySQL, PostgreSQL)"]},{"i":"lsm-tree-mostly-nosql-like-cassandra","l":"LSM Tree (mostly nosql like Cassandra)","p":["Best for: Heavy writing.","Key Points:","Writes data to memory first.","Moves data to disk in sorted order when memory is full, called SSTable.","Reading can get slower with more and more SSTable created on disk.","Widely used in NoSQL databases like Cassandra, HBase, and LevelDB.","Supports high scalability and can handle large datasets efficiently."]},{"l":"In Summary","p":["Hashmaps: Fast lookups in memory, used for caching or in-memory databases.","B-Trees: Efficient on-disk storage, used in relational databases for indexing.","LSM Trees: High write throughput, used in NoSQL databases for handling heavy writes."]}],[{"l":"Data warehouse"},{"i":"what-are-data-warehouses","l":"What are Data Warehouses?","p":["A data warehouse is a centralized repository that stores large amounts of structured data from multiple sources. It is designed for query and analysis rather than transaction processing. Data warehouses support business intelligence activities, such as reporting, data analysis, and data mining, providing valuable insights for decision-making."]},{"i":"data-extraction-transformation-and-loading-etl","l":"Data Extraction, Transformation, and Loading (ETL):","p":["Extraction: Data is collected from various source systems like transactional databases, CRM systems, and flat files.","Transformation: The extracted data is cleansed, formatted, and transformed into a consistent structure.","Loading: The transformed data is loaded into the data warehouse."]},{"l":"Fact and Dimension Tables","p":["1","1001","101","150.00","2","201","2020","2020-01-01","20200101","35","75.00","age","category","Content: Contains foreign keys to dimension tables and metrics like sales amount and quantity sold.","Content: Contains primary keys and attributes like product name, customer location, and store region.","customer_dimension_table","customer_id","customer_name","date","date_dimension_table","date_id","Dimension Tables:","Example:","Examples:","Fact Tables:","Gadgets","Jan","John Doe","location","month","New York","price","product_dimension_table","product_id","product_name","Purpose: Provide context and descriptive information related to facts.","Purpose: Store measurable, quantitative data for analysis.","Q1","quantity_sold","quarter","sale_id","sales_amount","sales_fact_table","store_id","Widget A","year"]},{"i":"star-snowflake-olap","l":"Star, Snowflake, OLAP","p":["Star Schema: Simplifies queries by having a central fact table surrounded by dimension tables.","Snowflake Schema: Normalizes dimension tables to reduce redundancy but can complicate queries.","OLAP (Online Analytical Processing): Tools and techniques used to analyze data in the warehouse, often supporting complex queries and data aggregation."]}],[{"l":"Indexes","p":["B-Tree","Balanced tree, keeps data sorted","Best For","Can be slower for large datasets compared to clustered","Clustered","Complex to implement, can degrade with irregular data","Efficient for location-based queries","Efficient for quick lookups","Efficient searches, range queries","Exact match lookups","Extremely fast exact match lookups","Fast for retrieving ordered rows","Full-Text","General-purpose indexing","Geospatial queries","Handles complex text searches","Hash","Hash table, maps keys to values","Index Type","Inverted index, tracks word occurrences","Key Points","Limitations","Needs space and maintenance as it grows","No range queries, needs collision handling","Non-Clustered","Organizing rows by index key","Quick access to data","R-Trees, Quadtrees for spatial data","Resource-intensive, needs extra storage","Separate from table, contains pointers to data","Slower for inserts/updates due to reordering","Spatial","Stores actual table data at index leaf level","Strengths","Text search"]},{"l":"B-Tree Indexes","p":["General-purpose indexing in databases.","Key Points:","Structure: Balanced tree; keeps data sorted.","Performance: Good for finding specific values and range queries.","Uses: Common in MySQL, PostgreSQL, Oracle.","Strengths:","Efficient searches, inserts, and deletes.","Supports range queries.","Limitations: Requires more space and maintenance as it grows."]},{"l":"Hash Indexes","p":["Fast lookups for exact matches.","Key Points:","Structure: Hash table; maps keys to values.","Performance: Very fast for finding exact matches.","Uses: In-memory databases like Redis; some uses in MySQL.","Strengths:","Extremely fast exact match lookups.","Limitations:","No range queries.","Needs handling for hash collisions."]},{"l":"Full-Text Indexes","p":["Searching large text fields.","Key Points:","Structure: Inverted index; tracks occurrences of each word.","Performance: Optimized for text search.","Uses: Elasticsearch, MySQL, PostgreSQL for full-text search.","Strengths:","Handles complex searches (e.g., relevance, ranking).","Limitations:","Can be resource-intensive.","Requires additional storage space."]},{"l":"Clustered Indexes","p":["With a clustered index the rows are stored physically on the disk in the same order as the index. Therefore, there can be only one clustered index.","Key Points:","Structure: Stores actual table data at the leaf level of the index.","Performance: Fast for retrieving rows in sorted order.","Uses: Each table can have only one clustered index (e.g., primary key in SQL Server).","Strengths:","Fast data retrieval for ordered data.","Limitations:","Slower for insert and update operations due to reordering."]},{"l":"Non-Clustered Indexes","p":["With a non clustered index there is a second list that has pointers to the physical rows. You can have many non clustered indices, although each new index will increase the time it takes to write new records.","Key Points:","Structure: Separate from the table; contains pointers to the data.","Performance: Good for queries that don't require sorted data.","Uses: Multiple non-clustered indexes can exist per table.","Strengths:","Efficient for quick lookups.","Limitations:","Can be slower than clustered indexes for large datasets."]},{"l":"Spatial Indexes","p":["Geospatial queries and multi-dimensional data.","Key Points:","Structure: R-Trees, Quadtrees, etc.; organizes spatial data.","Performance: Efficient for spatial operations.","Uses: GIS, spatial databases like PostGIS, MySQL.","Strengths:","Efficient for location-based queries.","Limitations:","Complex to implement.","Performance can degrade with irregular data."]}],[{"l":"Replication"},{"l":"Overview","p":["Replication in databases is a technique used to ensure data redundancy and high availability by copying and maintaining database objects in multiple databases that make up a distributed database system. There are several types of replication strategies, each with its own use cases, advantages, and challenges."]},{"l":"Types of Replication"},{"l":"Single-Leader Replication"},{"l":"Leader","p":["Role: The primary node handling all write requests.","Responsibilities: Accepts write requests, updates local data, propagates changes to followers."]},{"l":"Follower","p":["Role: Secondary nodes that replicate the leader's data.","Responsibilities: Receive and apply data changes from the leader, serve read requests."]},{"l":"Read-Write Dynamics","p":["Writes: Only accepted by the leader.","Reads: Distributed across followers to balance load and improve read performance."]},{"l":"Advantages","p":["Simplifies conflict resolution since only one node handles writes.","Ensures data consistency at the leader."]},{"l":"Disadvantages","p":["Can be slow, if done synchronously.","Single point of failure unless proper failover mechanisms are in place."]},{"l":"Multi-Leader Replication"},{"l":"Use Cases","p":["Suitable for high availability and geographically distributed systems.","Allows multiple nodes to accept write requests."]},{"l":"Write Conflicts","p":["Conflict Detection: Conflicts are detected asynchronously.","Resolution Strategies: Application-specific logic, Last Write Wins (LWW), vector clocks, and CRDTs."]},{"i":"advantages-1","l":"Advantages","p":["Provides higher write availability and fault tolerance.","Reduces latency for geographically distributed nodes."]},{"i":"disadvantages-1","l":"Disadvantages","p":["Increased complexity in conflict detection and resolution.","Potential for data inconsistency if conflicts are not properly resolved. You can decide to implement some algorithm to automatically resolve conflicts in a consistent manner (e.g., using a unique ID composed of timestamp and randomly generated)."]},{"l":"Replication Techniques"},{"l":"Synchronous Replication","p":["Mechanism: Ensures data is written to the leader and at least one follower before acknowledging the write.","Pros: Reduces inconsistency.","Cons: Can impact performance and availability if synchronous followers experience downtime."]},{"l":"Asynchronous Replication","p":["Mechanism: Data is written to the leader first and then asynchronously propagated to followers.","Pros: Improves write performance.","Cons: Increases the window for potential inconsistency."]},{"l":"Setting Up New Followers"},{"l":"Process","p":["Snapshot: Take a consistent snapshot of the leaderâ€™s database.","Copy Snapshot: Transfer the snapshot to the new follower.","Catch-Up: The follower requests and applies changes from the leader that occurred since the snapshot.","Synchronization: Once caught up, the follower processes ongoing changes in real-time."]},{"l":"Replication Logs"},{"i":"write-ahead-log-wal-shipping","l":"Write-ahead Log (WAL) Shipping","p":["Description: Logs every modification and ships these logs to followers.","Pros: Simple, works at a low level.","Cons: Coupled to storage engine, may require downtime for upgrades."]},{"i":"logical-row-based-log-replication","l":"Logical (Row-based) Log Replication","p":["Description: Uses a log format decoupled from the storage engine, recording changes at the row level.","Pros: Easier upgrades and external parsing.","Cons: More complex to implement than WAL shipping."]}],[{"l":"Sharding"}],[{"l":"Page title here","p":["This is a paragraph.","Both internal and external links work.","Your logo","Another paragraph with bold, italic, strikethrough, and code samples."]},{"l":"Lists","p":["First item","Second item","Third item","\"Cool! This is a quotation.\"","Need to draw attention to something? Use an alert."]}]]