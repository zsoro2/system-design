[[{"l":"Welcome","p":["test"]}],[{"l":"Twitter posts publish","p":["asd"]}],[{"l":"Data structures","p":["Data Structure","Best for","Key Points","Hashmaps","Fast lookups","In memory, loses data if off, no range queries","B-Trees","Database searches","On disk, supports range queries","LSM Trees","Heavy writing","Writes to memory first, then sorted to disk"]},{"l":"Hasmaps","p":["Best for: Fast lookups in memory.","Key Points:","Data is kept in memory.","Loses data if the computer shuts down.","Slow on disk.","No range queries."]},{"l":"B-Trees","p":["Best for: Databases with lots of searches.","Key Points:","Data is always on disk.","Good for range queries.","Efficient for frequent searches, inserts, and deletes.","Used in file systems and database indexes (e.g., MySQL, PostgreSQL)"]},{"i":"lsm-tree-mostly-nosql-like-cassandra","l":"LSM Tree (mostly nosql like Cassandra)","p":["Best for: Heavy writing.","Key Points:","Writes data to memory first.","Moves data to disk in sorted order when memory is full, called SSTable.","Reading can get slower with more and more SSTable created on disk.","Widely used in NoSQL databases like Cassandra, HBase, and LevelDB.","Supports high scalability and can handle large datasets efficiently."]},{"l":"In Summary","p":["Hashmaps: Fast lookups in memory, used for caching or in-memory databases.","B-Trees: Efficient on-disk storage, used in relational databases for indexing.","LSM Trees: High write throughput, used in NoSQL databases for handling heavy writes."]}],[{"l":"Data warehouse"},{"i":"what-are-data-warehouses","l":"What are Data Warehouses?","p":["A data warehouse is a centralized repository that stores large amounts of structured data from multiple sources. It is designed for query and analysis rather than transaction processing. Data warehouses support business intelligence activities, such as reporting, data analysis, and data mining, providing valuable insights for decision-making."]},{"i":"data-extraction-transformation-and-loading-etl","l":"Data Extraction, Transformation, and Loading (ETL):","p":["Extraction: Data is collected from various source systems like transactional databases, CRM systems, and flat files.","Transformation: The extracted data is cleansed, formatted, and transformed into a consistent structure.","Loading: The transformed data is loaded into the data warehouse."]},{"l":"Fact and Dimension Tables","p":["1","1001","101","150.00","2","201","2020","2020-01-01","20200101","35","75.00","age","category","Content: Contains foreign keys to dimension tables and metrics like sales amount and quantity sold.","Content: Contains primary keys and attributes like product name, customer location, and store region.","customer_dimension_table","customer_id","customer_name","date","date_dimension_table","date_id","Dimension Tables:","Example:","Examples:","Fact Tables:","Gadgets","Jan","John Doe","location","month","New York","price","product_dimension_table","product_id","product_name","Purpose: Provide context and descriptive information related to facts.","Purpose: Store measurable, quantitative data for analysis.","Q1","quantity_sold","quarter","sale_id","sales_amount","sales_fact_table","store_id","Widget A","year"]},{"i":"star-snowflake-olap","l":"Star, Snowflake, OLAP","p":["Star Schema: Simplifies queries by having a central fact table surrounded by dimension tables.","Snowflake Schema: Normalizes dimension tables to reduce redundancy but can complicate queries.","OLAP (Online Analytical Processing): Tools and techniques used to analyze data in the warehouse, often supporting complex queries and data aggregation."]}],[{"l":"Indexes","p":["B-Tree","Balanced tree, keeps data sorted","Best For","Can be slower for large datasets compared to clustered","Clustered","Complex to implement, can degrade with irregular data","Efficient for location-based queries","Efficient for quick lookups","Efficient searches, range queries","Exact match lookups","Extremely fast exact match lookups","Fast for retrieving ordered rows","Full-Text","General-purpose indexing","Geospatial queries","Handles complex text searches","Hash","Hash table, maps keys to values","Index Type","Inverted index, tracks word occurrences","Key Points","Limitations","Needs space and maintenance as it grows","No range queries, needs collision handling","Non-Clustered","Organizing rows by index key","Quick access to data","R-Trees, Quadtrees for spatial data","Resource-intensive, needs extra storage","Separate from table, contains pointers to data","Slower for inserts/updates due to reordering","Spatial","Stores actual table data at index leaf level","Strengths","Text search"]},{"l":"B-Tree Indexes","p":["General-purpose indexing in databases.","Key Points:","Structure: Balanced tree; keeps data sorted.","Performance: Good for finding specific values and range queries.","Uses: Common in MySQL, PostgreSQL, Oracle.","Strengths:","Efficient searches, inserts, and deletes.","Supports range queries.","Limitations: Requires more space and maintenance as it grows."]},{"l":"Hash Indexes","p":["Fast lookups for exact matches.","Key Points:","Structure: Hash table; maps keys to values.","Performance: Very fast for finding exact matches.","Uses: In-memory databases like Redis; some uses in MySQL.","Strengths:","Extremely fast exact match lookups.","Limitations:","No range queries.","Needs handling for hash collisions."]},{"l":"Full-Text Indexes","p":["Searching large text fields.","Key Points:","Structure: Inverted index; tracks occurrences of each word.","Performance: Optimized for text search.","Uses: Elasticsearch, MySQL, PostgreSQL for full-text search.","Strengths:","Handles complex searches (e.g., relevance, ranking).","Limitations:","Can be resource-intensive.","Requires additional storage space."]},{"l":"Clustered Indexes","p":["With a clustered index the rows are stored physically on the disk in the same order as the index. Therefore, there can be only one clustered index.","Key Points:","Structure: Stores actual table data at the leaf level of the index.","Performance: Fast for retrieving rows in sorted order.","Uses: Each table can have only one clustered index (e.g., primary key in SQL Server).","Strengths:","Fast data retrieval for ordered data.","Limitations:","Slower for insert and update operations due to reordering."]},{"l":"Non-Clustered Indexes","p":["With a non clustered index there is a second list that has pointers to the physical rows. You can have many non clustered indices, although each new index will increase the time it takes to write new records.","Key Points:","Structure: Separate from the table; contains pointers to the data.","Performance: Good for queries that don't require sorted data.","Uses: Multiple non-clustered indexes can exist per table.","Strengths:","Efficient for quick lookups.","Limitations:","Can be slower than clustered indexes for large datasets."]},{"l":"Spatial Indexes","p":["Geospatial queries and multi-dimensional data.","Key Points:","Structure: R-Trees, Quadtrees, etc.; organizes spatial data.","Performance: Efficient for spatial operations.","Uses: GIS, spatial databases like PostGIS, MySQL.","Strengths:","Efficient for location-based queries.","Limitations:","Complex to implement.","Performance can degrade with irregular data."]}],[{"l":"Sharding"}],[{"l":"Page title here","p":["This is a paragraph.","Both internal and external links work.","Your logo","Another paragraph with bold, italic, strikethrough, and code samples."]},{"l":"Lists","p":["First item","Second item","Third item","\"Cool! This is a quotation.\"","Need to draw attention to something? Use an alert."]}]]